(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{356:function(t,s,a){t.exports=a.p+"assets/img/640.d0bd6221.jpeg"},445:function(t,s,a){"use strict";a.r(s);var e=a(9),n=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[t._v("#")]),t._v(" 分布式锁")]),t._v(" "),s("h2",{attrs:{id:"redis-分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-分布式锁"}},[t._v("#")]),t._v(" Redis 分布式锁")]),t._v(" "),s("p",[t._v("可参考 "),s("a",{attrs:{href:"https://github.com/redisson/redisson/wiki/8.-distributed-locks-and-synchronizers#81-lock",target:"_blank",rel:"noopener noreferrer"}},[t._v(" Distributed locks and synchronizers · redisson/redisson Wiki"),s("OutboundLink")],1),t._v(" 理解。")]),t._v(" "),s("p",[t._v("Redis 锁主要利用 Redis 的 setnx 命令。")]),t._v(" "),s("ul",[s("li",[t._v("加锁命令：SETNX key value，当键不存在时，对键进行设置操作并返回成功，否则返回失败。KEY 是锁的唯一标识，value 是线程 id。")]),t._v(" "),s("li",[t._v("解锁命令：DEL key，通过删除键值对释放锁，删之前要判断当前线程持有锁。")]),t._v(" "),s("li",[t._v("锁超时：EXPIRE key timeout, 设置 key 的超时时间，是为了避免死锁，当系统奔溃，未能显示解锁。")])]),t._v(" "),s("p",[t._v("伪代码")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setnx")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("expire")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("30")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        xxx\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("finally")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("del")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("setnx 和 expire 是两条指令，不能保证原子性，使用 lua 操作，保证二者原子性。")]),t._v(" "),s("p",[t._v("redis 2.6.12 版本以上也提供了 "),s("code",[t._v("set（key，1，30，NX")]),t._v(" 来保证原子性。")]),t._v(" "),s("p",[t._v("当获取的锁，没有超时时间。但是 redis 会设置 key 的过期时间，不能保证锁的互斥性。可以采取 watch dog （一个线程）去定时给这个 key 续期。")]),t._v(" "),s("p",[t._v("锁重入，可在 redis 中保存重入的次数，"),s("code",[t._v("set threaId 1")]),t._v(" 然后往上加。")]),t._v(" "),s("h3",{attrs:{id:"锁失效场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#锁失效场景"}},[t._v("#")]),t._v(" 锁失效场景")]),t._v(" "),s("p",[t._v("1、主备切换导致锁的数据没有同步过来，新的 master 同时又可以被一个另一个进程获取锁，破坏了锁的互斥性。")]),t._v(" "),s("p",[t._v("2、集群脑裂，因为网络分区，sentinel 无法感知到 master，故障转移，将一个从节点提升为 master，导致集群出现两个 不同的master，新的 redis 链接也可获得同一把锁。")]),t._v(" "),s("p",[t._v("3、GC 停顿时间太长，GC 的时候 STW（stop-the-world）时间太长，导致锁过期，watch dog 没办法去延长过期时间。")]),t._v(" "),s("h2",{attrs:{id:"zookeeper-分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper-分布式锁"}},[t._v("#")]),t._v(" ZooKeeper 分布式锁")]),t._v(" "),s("p",[t._v("ZK 的数据节点和文件目录类似，所以我们可以"),s("strong",[t._v("临时顺序节点")]),t._v("实现分布式锁。")]),t._v(" "),s("p",[s("img",{attrs:{src:a(356),alt:"Image"}})]),t._v(" "),s("p",[t._v("我们在锁的下面创建临时顺序节点，节点最小的那个客户端获取到锁。")]),t._v(" "),s("p",[t._v("解锁删除临时节点 01")]),t._v(" "),s("p",[t._v("锁超时，当创建这个锁的链接断掉，zk 会删掉这个临时节点。")])])}),[],!1,null,null,null);s.default=n.exports}}]);