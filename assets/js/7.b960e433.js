(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{301:function(s,t,a){s.exports=a.p+"assets/img/mysql-architecture.a92561fb.png"},302:function(s,t,a){s.exports=a.p+"assets/img/b843a63ac8c3b1dc07c8dd5d63b98107.2cbcc01c.png"},303:function(s,t,a){s.exports=a.p+"assets/img/image-20240324141110463.2f7b37c9.png"},304:function(s,t,a){s.exports=a.p+"assets/img/badecbaedbf1e38410e5686f7684852a.9e013d02.jpeg"},305:function(s,t,a){s.exports=a.p+"assets/img/20200921183000.5c99b36c.png"},306:function(s,t,a){s.exports=a.p+"assets/img/mysql_data_jiegou.be467b46.png"},396:function(s,t,a){"use strict";a.r(t);var e=a(9),r=Object(e.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"mysql-架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql-架构"}},[s._v("#")]),s._v(" Mysql 架构")]),s._v(" "),t("h2",{attrs:{id:"mysql-架构说明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql-架构说明"}},[s._v("#")]),s._v(" Mysql 架构说明")]),s._v(" "),t("p",[t("img",{attrs:{src:a(301),alt:"img"}})]),s._v(" "),t("p",[s._v("上图为 Mysql 8.0 官网架构图。Mysql 是一个 C/S 架构的程序。")]),s._v(" "),t("p",[s._v("Mysql 的 Server 端内部又又可以分为 "),t("code",[s._v("server")]),s._v(" 和 "),t("code",[s._v("存储引擎")]),s._v(" 两部分。我们查询数据，一般是 server 层和存储引擎打交道，然后存储引擎再给我们数据文件系统打交道，从里面找出我们需要的数据。")]),s._v(" "),t("h3",{attrs:{id:"mysql-工作流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql-工作流程"}},[s._v("#")]),s._v(" Mysql 工作流程")]),s._v(" "),t("p",[t("img",{attrs:{src:a(302),alt:"img"}})]),s._v(" "),t("ol",[t("li",[s._v("当一个客户端向服务端发送连接请求后，MySQL Server 会从线程池中分配一个线程来和客户端进行连接，以后该客户端的请求都会被分配到该线程上。如果这个链接（jdbc 连接）空闲 8 个小时，Mysql 会断掉这个链接。"),t("code",[s._v("wait_timeout")]),s._v(" 控制。")]),s._v(" "),t("li",[s._v("当我们执行查询语句时，如果命中缓存直接返回查询数据。如果没有命中缓存，SQL 解析，SQL 优化生成执行计划，然后 server 层调用存储引擎层进行数据查询，其中 server 层和存储引擎层可能会多次打交道把数据查询出来。")]),s._v(" "),t("li",[s._v("存储引擎查询索引或者表数据文件，得到数据返回给 server 层，然后 server 层返回给 client。")])]),s._v(" "),t("p",[s._v("Mysql 将数据储存在硬盘上，为了提高查询速度，比较好的做法是将索引数据和一部分热数据（经常访问的数据）放到内存中（Mysql 的 "),t("strong",[s._v("Buffer Poll")]),s._v("）。")]),s._v(" "),t("p",[s._v("当检索数据的时候，Mysql 通过索引查找，就可以知道数据在磁盘哪块了，从硬盘对应位置读取对应的数据到内存中返回给 server 层。")]),s._v(" "),t("h2",{attrs:{id:"mysql-存储文件介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql-存储文件介绍"}},[s._v("#")]),s._v(" Mysql 存储文件介绍")]),s._v(" "),t("h3",{attrs:{id:"查看-mysql-数据文件的目录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查看-mysql-数据文件的目录"}},[s._v("#")]),s._v(" 查看 Mysql 数据文件的目录")]),s._v(" "),t("div",{staticClass:"language-sql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("show")]),s._v(" variables "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("like")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'%datadir%'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),t("p",[s._v("linux 下一般存储位置就是 "),t("code",[s._v("/var/lib/mysql/")]),s._v(" 。")]),s._v(" "),t("h3",{attrs:{id:"系统表空间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#系统表空间"}},[s._v("#")]),s._v(" 系统表空间")]),s._v(" "),t("p",[s._v("系统表空间是所有表共享的，它保存了数据表结构，事务信息 等")]),s._v(" "),t("div",{staticClass:"language-sql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SHOW")]),s._v(" VARIABLES "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("LIKE")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'innodb_data_file_path%'")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- ibdata1:12M:autoextend")]),s._v("\n")])])]),t("h3",{attrs:{id:"独立表空间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#独立表空间"}},[s._v("#")]),s._v(" 独立表空间")]),s._v(" "),t("p",[t("strong",[s._v("Mysql 8.0 是默认开启独立表空间的")]),s._v("，默认每张表使用一个文件进行保存数据和索引")]),s._v(" "),t("div",{staticClass:"language-sql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 查看是否开启独立表空间配置")]),s._v("\nmysql"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("show")]),s._v(" variables "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("like")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'%innodb_file_per_table%'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-----------------------+-------+")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" Variable_name         "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("Value")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-----------------------+-------+")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" innodb_file_per_table "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("ON")]),s._v("    "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-----------------------+-------+")]),s._v("\n")])])]),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[s._v("TIP")]),s._v(" "),t("p",[s._v("独立表空间是指每张表单独用一个文件储存每张表对应的表结构、数据和索引，文件扩展名为 ibd。")]),s._v(" "),t("p",[s._v("每个数据库会有一个对应目录用于保存当前数据库中的数据文件")])]),s._v(" "),t("p",[s._v("比如我有一个 sandbox 数据库，这个库里创建了两个表 order 和 user。")]),s._v(" "),t("p",[s._v("那么 "),t("code",[s._v("/var/lib/mysql/sandbox")]),s._v(" 存储的就是这个 sandbox 数据库的数据。")]),s._v(" "),t("div",{staticClass:"language-txt extra-class"},[t("pre",{pre:!0,attrs:{class:"language-txt"}},[t("code",[s._v("ls -l /var/lib/mysql/sandbox/\n-rw-r----- 1 mysql mysql 131072 Mar 23 15:27 order.ibd\n-rw-r----- 1 mysql mysql 163840 Mar 23 15:12 user.ibd\n")])])]),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[s._v("TIP")]),s._v(" "),t("p",[s._v("当我们在某个数据库中创建一张表时，除了在系统表空间生成元数据和表结构，也会在对应的数据库目录下，新建一个 tablename.ibd 文件。")])]),s._v(" "),t("h2",{attrs:{id:"innodb-存储引擎架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#innodb-存储引擎架构"}},[s._v("#")]),s._v(" InnoDB 存储引擎架构")]),s._v(" "),t("p",[t("img",{attrs:{src:a(303),alt:"image-20240324141110463"}})]),s._v(" "),t("h3",{attrs:{id:"buffer-pool"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#buffer-pool"}},[s._v("#")]),s._v(" Buffer Pool")]),s._v(" "),t("p",[t("code",[s._v("Buffer Poll")]),s._v(" 是主存中的一个区域，缓存 InnoDB 访问过的表和索引数据。在专用服务器上，高达 80% 的物理内存通常分配给缓冲池。")]),s._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[s._v("TIP")]),s._v(" "),t("p",[s._v("Buffer Pool 是一片连续的内存空间，然后按照默认的 "),t("code",[s._v("16KB")]),s._v(" 的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页。")]),s._v(" "),t("p",[s._v("当查询数据时，InnoDB 是会把整个页的数据加载到 Buffer Pool 中。因为，通过索引只能定位到磁盘中的页，而不能定位到页中的一条记录。将页加载到 Buffer Pool 后，再通过页里的页目录去定位到某条具体的记录。")])]),s._v(" "),t("p",[s._v("LRU（Least recently used）算法保证了频繁访问的数据一直留在 Buffer Pool 中，而一些很少访问的数据在某些时机淘汰掉，从而保证 Buffer Pool 不会因为满了而导致无法再缓存新的数据，同时还能保证常用数据留在 Buffer Pool 中。")]),s._v(" "),t("p",[s._v("当我们要修改的数据在 "),t("code",[s._v("Buffer Poll")]),s._v(" 中，直接修改缓存页，在落盘就行了。")]),s._v(" "),t("p",[s._v("但是有的时候，我们修改的页不在 "),t("code",[s._v("Buffer Poll")]),s._v(" 中，如果没有 change buffer，InnoDB 会将数据所在页加载到"),t("code",[s._v("Buffer Poll")]),s._v(" ，修改，再落盘。为了提高效率，引入了 change buffer，想将修改操作写入 redo log 中，而不必加载数据。当再次读取到这页数据时，将 change buffer 中的页和数据页合并，达到数据一致性效果。")]),s._v(" "),t("p",[t("strong",[s._v("Change Buffer")]),s._v(" 它应用在**非唯一普通索引页（non-unique secondary index page）。")]),s._v(" "),t("h3",{attrs:{id:"binlog"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#binlog"}},[s._v("#")]),s._v(" binlog")]),s._v(" "),t("p",[s._v("binlog 是 server 层的，不管那个存储引擎都会有 binlog。Mysql 主从复制和备份都是依靠 binlog。")]),s._v(" "),t("p",[t("code",[s._v("binlog")]),s._v(" 日志有三种格式，可以通过 "),t("code",[s._v("binlog_format")]),s._v(" 参数指定。")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("statement")]),s._v("，会记录所有执行成功 DDL 和 DML（不包括 select 语句）操作，包括"),t("code",[s._v("UPDATE和DELETE")]),s._v("操作影响行数为 0 的情况。")]),s._v(" "),t("li",[t("strong",[s._v("row")]),s._v("，会记录所有执行成功 DDL 和 DML（不包括 select 语句）操作，"),t("code",[s._v("UPDATE和DELETE")]),s._v("操作影响行数为 0 的不会记录。")]),s._v(" "),t("li",[t("strong",[s._v("mixed")]),s._v("，用 "),t("strong",[s._v("row")]),s._v(" 时符合 "),t("strong",[s._v("row")]),s._v(" 规则，用 "),t("strong",[s._v("statement")]),s._v(" 符合 "),t("strong",[s._v("statement")]),s._v(" 规则")])]),s._v(" "),t("p",[s._v("binlog_format 指定 "),t("code",[s._v("statement")]),s._v("，记录的内容是"),t("code",[s._v("SQL")]),s._v("语句原文，比如执行一条 "),t("code",[s._v("update a set update_time=now() where id=1")]),s._v("，记录的内容如下。但是 now() 会导致数据不一样。")]),s._v(" "),t("p",[s._v("为了解决这个问题，有 row，记录的是数据的修改值。")]),s._v(" "),t("p",[s._v("如果一个 SQL，修改了全表数据，row 模式会非常大，同步的时候消耗更多的 io 资源，延迟也高。")]),s._v(" "),t("p",[s._v("为了解决这个问题，引入了 mixed ，MySQL 会判断这条 SQL 语句是否可能引起数据不一致，如果是，就用 row 格式，否则就用 statement 格式。")]),s._v(" "),t("h3",{attrs:{id:"redo-log"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redo-log"}},[s._v("#")]),s._v(" redo log")]),s._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[s._v("TIP")]),s._v(" "),t("p",[s._v("redo log 保证了数据的持久性。属于 InnoDB。")])]),s._v(" "),t("p",[t("code",[s._v("InnoDB")]),s._v(" 存储引擎是以页为单位来管理存储空间。当 InnoDB 读取磁盘上的页数据到 Buffer Pool 中，修改了数据，将 Buffer Pool 中对应的页落盘。如果一条 SQL 修改的大量数据分布零散，当这些页都写入到磁盘时，随机 io 性能太拉。")]),s._v(" "),t("p",[s._v("我们只是想持久化数据的修改，即使后来系统崩溃，在重启后也能把这种修改恢复过来。redo log 就是做这个的，提交事务的时候，它将我们修改的字段数据顺序写入到日志文件中，而不必将脏页持久化。")]),s._v(" "),t("p",[s._v("写 redo log 的时候，实际先顺序写入到 Buffer Pool 中的 Log Buffer，当我们提交事务或者 Log Buffer 空间不足时，在讲 Log Buffer 落盘，页持久化了 redo log。")]),s._v(" "),t("h3",{attrs:{id:"两阶段提交"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#两阶段提交"}},[s._v("#")]),s._v(" 两阶段提交")]),s._v(" "),t("p",[t("code",[s._v("redo log")]),s._v(" 让 InnoDB 存储引擎拥有了崩溃恢复能力，保证数据的持久性")]),s._v(" "),t("p",[t("code",[s._v("binlog")]),s._v(" 保证了 MySQL 集群架构的数据一致性。")]),s._v(" "),t("p",[s._v("如果这两个日志逻辑不一样，会导致数据丢失或者没通过成功。")]),s._v(" "),t("p",[s._v("为了解决两份日志之间的逻辑一致问题，"),t("code",[s._v("InnoDB")]),s._v("存储引擎使用"),t("strong",[s._v("两阶段提交")]),s._v("方案。")]),s._v(" "),t("p",[s._v("原理很简单，将 "),t("code",[s._v("redo log")]),s._v(" 的写入拆成了两个步骤"),t("code",[s._v("prepare")]),s._v("和"),t("code",[s._v("commit")]),s._v("，这就是"),t("strong",[s._v("两阶段提交")]),s._v("。")]),s._v(" "),t("p",[t("img",{attrs:{src:a(304),alt:"img"}})]),s._v(" "),t("p",[s._v("第一阶段提交，redo log 处于 prepare 状态落盘，然后 server 层写入 binlog （cache）。")]),s._v(" "),t("p",[s._v("第二阶段提交，binlog 落盘，redo log 处于 commit 状态落盘。")]),s._v(" "),t("p",[s._v("下面我们分析一下，两阶段提交的好处")]),s._v(" "),t("p",[s._v("情景一，redo log 处于 prepare 状态时，如果写 bin log 失败了，那么更新失败，此时 redo log 没有 commit，bin log 也没有记录，两者的状态是一致的，没有问题。")]),s._v(" "),t("p",[s._v("情景二，redo log 处于 prepare 状态时，写 bin log 成功，但是宕机导致 commit 失败了。此时 bin log 产生了记录，redo log 没有写入成功，数据暂时不一致。")]),s._v(" "),t("p",[s._v("当 MySQL 重启时，会检查 redo log 中处于 prepare 状态的记录。在 redo log 中，记录了一个叫做 XID 的字段，这个字段在 bin log 中也有记录，MySQL 会通过这个 XID，如果在 bin log 中找到了，那么就 commit 这个 redo log，如果没有找到，说明 bin log 其实没有写成功，就放弃提交。")]),s._v(" "),t("h3",{attrs:{id:"分布式事务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务"}},[s._v("#")]),s._v(" 分布式事务")]),s._v(" "),t("p",[s._v("分布式事务是指一个全局事务中，有多个 mysql 参与的小事务组成一个大事务。")]),s._v(" "),t("p",[s._v("XA 规范提出 2 个角色：")]),s._v(" "),t("ul",[t("li",[s._v("一个全局事务由多个小的事务组成，所以我们得在某个地方找一个总揽全局的家伙，这个家伙用于和各个小事务进行沟通，指导它们是提交还是回滚。这个家伙被称作事务协调器（Transaction Coordinator）")]),s._v(" "),t("li",[s._v("管理一个小事务的家伙被称作事务管理器（Transaction Manager）。")])]),s._v(" "),t("p",[s._v("此时 XA 规范中指出，要提交一个全局事务，必须分为 2 步：")]),s._v(" "),t("ul",[t("li",[s._v("Prepare 阶段："),t("strong",[s._v("事务协调器")]),s._v("通知"),t("strong",[s._v("事务管理器")]),s._v(" redo log 落盘。")]),s._v(" "),t("li",[s._v("Commit 阶段：第一阶段都 ok，然后"),t("strong",[s._v("事务协调器")]),s._v("通知"),t("strong",[s._v("事务管理器")]),s._v("提交事务。")])]),s._v(" "),t("h4",{attrs:{id:"mysql-中的-xa-事务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql-中的-xa-事务"}},[s._v("#")]),s._v(" MySQL 中的 XA 事务")]),s._v(" "),t("ul",[t("li",[t("code",[s._v("XA {START|BEGIN} xid")]),s._v("：该语句用于开启一个 XA 事务，此时该 XA 事务处于 "),t("code",[s._v("ACTIVE")]),s._v(" 状态。")]),s._v(" "),t("li",[t("code",[s._v("XA END xid")]),s._v("：在使用"),t("code",[s._v("XA START xid")]),s._v("开启了一个 XA 事务后，客户端就可以接着发送属于这个 XA 事务的各条语句，等所有语句都发送完毕后，就可以接着发送"),t("code",[s._v("XA END xid")]),s._v("来告知服务器由"),t("code",[s._v("xid")]),s._v("标识的 XA 事务的所有语句都输入完了。此时该 XA 事务处于"),t("code",[s._v("IDLE")]),s._v("状态。")]),s._v(" "),t("li",[t("code",[s._v("XA PREPARE xid")]),s._v("：对于处于"),t("code",[s._v("IDLE")]),s._v("状态的 XA 事务，应用程序就可以询问 MySQL 服务器是否准备好提交这个 XA 事务了，此时就可以给服务器发送"),t("code",[s._v("XA PREPARE xid")]),s._v("语句。当 MySQL 服务器收到此语句后，就需要做准备提交前的工作了，比如把该事务执行过程中所产生的 redo 日志刷新到磁盘等。此时 XA 事务处于"),t("code",[s._v("PREPARE")]),s._v("状态。")]),s._v(" "),t("li",[t("code",[s._v("XA COMMIT xid [ONE PHASE]")]),s._v("：对于处于"),t("code",[s._v("PREPARE")]),s._v("状态的 XA 事务，应用程序可以发送"),t("code",[s._v("XA COMMIT xid")]),s._v("来让 MySQL 服务器提交 XA 事务。如果此 XA 事务尚处于"),t("code",[s._v("IDEL")]),s._v("状态，那应用程序可以不发送"),t("code",[s._v("XA PREPARE xid")]),s._v("，而直接发送"),t("code",[s._v("XA COMMIT xid ONE PHASE")]),s._v("来让 MySQL 服务器直接提交事务即可。此 XA 事务处于"),t("code",[s._v("COMMITE")]),s._v("状态。")]),s._v(" "),t("li",[t("code",[s._v("XA ROLLBACK xid")]),s._v("：应用程序通过发送此语句来让 MySQL 服务器回滚 xid 所标识的事务。此时 XA 事务处于"),t("code",[s._v("ABORT")]),s._v("状态。")]),s._v(" "),t("li",[t("code",[s._v("XA RECOVER")]),s._v("：应用程序想看一下当前 MySQL 服务器上已经处于 Prepare 状态的 XA 事务有哪些，就可以发送该语句。")])]),s._v(" "),t("h3",{attrs:{id:"undo-log"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#undo-log"}},[s._v("#")]),s._v(" undo log")]),s._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[s._v("TIP")]),s._v(" "),t("p",[s._v("undo log 保证了数据的原子性。属于 InnoDB。")])]),s._v(" "),t("p",[s._v("undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。")]),s._v(" "),t("ul",[t("li",[s._v("在"),t("strong",[s._v("插入")]),s._v("一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录"),t("strong",[s._v("删掉")]),s._v("就好了；")]),s._v(" "),t("li",[s._v("在"),t("strong",[s._v("删除")]),s._v("一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录"),t("strong",[s._v("插入")]),s._v("到表中就好了；")]),s._v(" "),t("li",[s._v("在"),t("strong",[s._v("更新")]),s._v("一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列"),t("strong",[s._v("更新为旧值")]),s._v("就好了。")])]),s._v(" "),t("h4",{attrs:{id:"undo-log-的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#undo-log-的作用"}},[s._v("#")]),s._v(" Undo Log 的作用")]),s._v(" "),t("ol",[t("li",[s._v("Undo Log 用来记录每次修改之前的历史值，配合 Redo Log 用于故障恢复。")]),s._v(" "),t("li",[s._v("事务回滚")]),s._v(" "),t("li",[s._v("MVCC（Multi-Versioin Concurrency Control）")])]),s._v(" "),t("h3",{attrs:{id:"mvcc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mvcc"}},[s._v("#")]),s._v(" MVCC")]),s._v(" "),t("p",[s._v("事务 id 是由 Mysql 控制唯一且递增。")]),s._v(" "),t("p",[s._v("对于 "),t("code",[s._v("读提交")]),s._v(" 和 "),t("code",[s._v("可重复读")]),s._v(" 隔离级别的事务来说，快照读是通过 Read View + undo log 来实现的，它们的区别在于创建 Read View 的时机不同：")]),s._v(" "),t("ul",[t("li",[s._v("「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。")]),s._v(" "),t("li",[s._v("「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。")])]),s._v(" "),t("p",[s._v("这个 "),t("code",[s._v("ReadView")]),s._v(" 中主要包含 4 个比较重要的内容：")]),s._v(" "),t("ul",[t("li",[t("code",[s._v("m_ids")]),s._v("：表示在生成"),t("code",[s._v("ReadView")]),s._v("时当前系统中活跃的读写事务的"),t("code",[s._v("事务id")]),s._v("列表。")]),s._v(" "),t("li",[t("code",[s._v("min_trx_id")]),s._v("：表示在生成"),t("code",[s._v("ReadView")]),s._v("时当前系统中活跃的读写事务中最小的"),t("code",[s._v("事务id")]),s._v("，也就是"),t("code",[s._v("m_ids")]),s._v("中的最小值。")]),s._v(" "),t("li",[t("code",[s._v("max_trx_id")]),s._v("：表示生成"),t("code",[s._v("ReadView")]),s._v("时系统中应该分配给下一个事务的"),t("code",[s._v("id")]),s._v("值。")]),s._v(" "),t("li",[t("code",[s._v("creator_trx_id")]),s._v("：表示生成该"),t("code",[s._v("ReadView")]),s._v("的事务的"),t("code",[s._v("事务id")]),s._v("。")])]),s._v(" "),t("p",[s._v("有了这个"),t("code",[s._v("ReadView")]),s._v("，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：")]),s._v(" "),t("ul",[t("li",[s._v("如果被访问版本的"),t("code",[s._v("trx_id")]),s._v("属性值与"),t("code",[s._v("ReadView")]),s._v("中的"),t("code",[s._v("creator_trx_id")]),s._v("值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。")]),s._v(" "),t("li",[s._v("如果被访问版本的"),t("code",[s._v("trx_id")]),s._v("属性值小于"),t("code",[s._v("ReadView")]),s._v("中的"),t("code",[s._v("min_trx_id")]),s._v("值，表明生成该版本的事务在当前事务生成"),t("code",[s._v("ReadView")]),s._v("前已经提交，所以该版本可以被当前事务访问。")]),s._v(" "),t("li",[s._v("如果被访问版本的"),t("code",[s._v("trx_id")]),s._v("属性值大于或等于"),t("code",[s._v("ReadView")]),s._v("中的"),t("code",[s._v("max_trx_id")]),s._v("值，表明生成该版本的事务在当前事务生成"),t("code",[s._v("ReadView")]),s._v("后才开启，所以该版本不可以被当前事务访问。")]),s._v(" "),t("li",[s._v("如果被访问版本的"),t("code",[s._v("trx_id")]),s._v("属性值在"),t("code",[s._v("ReadView")]),s._v("的"),t("code",[s._v("min_trx_id")]),s._v("和"),t("code",[s._v("max_trx_id")]),s._v("之间，那就需要判断一下"),t("code",[s._v("trx_id")]),s._v("属性值是不是在"),t("code",[s._v("m_ids")]),s._v("列表中，如果在，说明创建"),t("code",[s._v("ReadView")]),s._v("时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建"),t("code",[s._v("ReadView")]),s._v("时生成该版本的事务已经被提交，该版本可以被访问。")])]),s._v(" "),t("p",[s._v("如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。")]),s._v(" "),t("h3",{attrs:{id:"数据存储介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据存储介绍"}},[s._v("#")]),s._v(" 数据存储介绍")]),s._v(" "),t("p",[t("img",{attrs:{src:a(305),alt:"image-20200921113000653"}})]),s._v(" "),t("h3",{attrs:{id:"表空间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#表空间"}},[s._v("#")]),s._v(" 表空间")]),s._v(" "),t("p",[s._v("在 "),t("code",[s._v("InnoDB")]),s._v(" 存储引擎下，表相关的所有数据（比如业务数据和索引数据）都储存在**表空间（tablespace）**中。每张表都有一个自己的文件（.ibd）去储存相关数据（开启独立表空间设置）。")]),s._v(" "),t("p",[s._v("表空间又可以细分为 "),t("code",[s._v("segment")]),s._v("，"),t("code",[s._v("extent")]),s._v("，"),t("code",[s._v("page")]),s._v("，"),t("code",[s._v("row")]),s._v("。")]),s._v(" "),t("h3",{attrs:{id:"段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#段"}},[s._v("#")]),s._v(" 段")]),s._v(" "),t("p",[s._v("表空间又包含多个段（segment），常见的数据段有：")]),s._v(" "),t("ul",[t("li",[t("code",[s._v("Leaf node segment")]),s._v(" 数据段，存储当前表中的数据")]),s._v(" "),t("li",[t("code",[s._v("Non-Leaf node segment")]),s._v(" 索引段，存储当前表中的索引")])]),s._v(" "),t("h3",{attrs:{id:"区"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#区"}},[s._v("#")]),s._v(" 区")]),s._v(" "),t("p",[s._v("段包含很多个区，每个区始终为 1MB 。区由多个连续连续的页组成，页的大小通常是 16KB，所以一个区可以有 64 （1024/16=64）个连续页。")]),s._v(" "),t("h3",{attrs:{id:"页"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#页"}},[s._v("#")]),s._v(" 页")]),s._v(" "),t("p",[t("strong",[s._v("页是 "),t("code",[s._v("InnoDB")]),s._v(" 与磁盘交互的最小单位")]),s._v("。从磁盘上读取数据，一次性是读取一页数据。将内存中的数据落盘到硬盘上，也是操作一页数据。")]),s._v(" "),t("p",[s._v("比如我们修改了 "),t("code",[s._v("id=3")]),s._v(" 某行数据，数据持久化的时候，是需要将这行所在的页全部落盘在硬盘上。")]),s._v(" "),t("div",{staticClass:"language-sql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("update")]),s._v(" test_table "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("set")]),s._v(" a"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" id "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),t("p",[s._v("页也有类型，数据页，索引页等等。")]),s._v(" "),t("div",{staticClass:"language-sql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("-- 查看页的大小，默认是 16KB =16*1024bit")]),s._v("\nmysql"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("show")]),s._v(" variables "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("like")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'%innodb_page_size%'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("------------------+-------+")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" Variable_name    "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("Value")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("------------------+-------+")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" innodb_page_size "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("16384")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("------------------+-------+")]),s._v("\n")])])]),t("h3",{attrs:{id:"行"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#行"}},[s._v("#")]),s._v(" 行")]),s._v(" "),t("p",[s._v("每页存放一行一行的数据。")]),s._v(" "),t("div",{staticClass:"language-sql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[s._v("mysql"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SHOW")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("TABLE")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("STATUS")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("LIKE")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"test_data_type"')]),s._v("\\G"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1.")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("row")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("\n           Name: test_data_type\n         "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("Engine")]),s._v(": "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("InnoDB")]),s._v("\n        Version: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),s._v("\n     Row_format: Dynamic\n           "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("Rows")]),s._v(": "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("22")]),s._v("\n Avg_row_length: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("14894")]),s._v("\n    Data_length: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("327680")]),s._v("\nMax_data_length: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v("\n   Index_length: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v("\n      Data_free: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v("\n "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("Auto_increment")]),s._v(": "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("243")]),s._v("\n    Create_time: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2020")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("09")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("21")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("01")]),s._v(":"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("55")]),s._v(":"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("51")]),s._v("\n    Update_time: "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2020")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("09")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("21")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("02")]),s._v(":"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("06")]),s._v(":"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("59")]),s._v("\n     Check_time: "),t("span",{pre:!0,attrs:{class:"token boolean"}},[s._v("NULL")]),s._v("\n      Collation: utf8mb4_0900_ai_ci\n       Checksum: "),t("span",{pre:!0,attrs:{class:"token boolean"}},[s._v("NULL")]),s._v("\n Create_options:\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("Comment")]),s._v(":\n")])])]),t("p",[t("code",[s._v("Row_format")]),s._v(" 定义了一行数据在数据页中怎么保存。")]),s._v(" "),t("p",[t("img",{attrs:{src:a(306),alt:"image_1c9h256f9nke14311adhtu61ie2dn.png-92kB"}})]),s._v(" "),t("p",[s._v("一个页一般是 "),t("code",[s._v("16KB")]),s._v("，当记录中的某个字段类型数据太大，当前页放不下的时候，会把多余的数据存储到其他页中，这种现象称为"),t("code",[s._v("行溢出")]),s._v("。")]),s._v(" "),t("p",[s._v("然后会在当前行数据中保存行溢出数据所在的页。")]),s._v(" "),t("p",[s._v("行数据中，除了我们表结构中自己定义的字段，还有 Mysql 添加的元数据字段。比如 "),t("code",[s._v("row_id")]),s._v("（当没有主键数据的时候添加），"),t("code",[s._v("transaction_id")]),s._v("（主要用于 MVCC）和 "),t("code",[s._v("roll_pointer")]),s._v(" 。")])])}),[],!1,null,null,null);t.default=r.exports}}]);