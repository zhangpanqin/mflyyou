(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{346:function(a,v,t){a.exports=t.p+"assets/img/20210323144335.6368cd6b.png"},347:function(a,v,t){a.exports=t.p+"assets/img/20210323144519.c2d43d4e.png"},348:function(a,v,t){a.exports=t.p+"assets/img/20210323171447-1196406.208e235c.png"},434:function(a,v,t){"use strict";t.r(v);var s=t(9),_=Object(s.a)({},(function(){var a=this,v=a._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"认识-java-运行时数据区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#认识-java-运行时数据区"}},[a._v("#")]),a._v(" 认识 Java 运行时数据区")]),a._v(" "),v("p",[a._v("Java 虚拟机在执行 java 程序的过程中会把它所管理的内存区域划分为不同的数据区域及 "),v("strong",[a._v("Java 运行时数据区")]),a._v("。")]),a._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[a._v("WARNING")]),a._v(" "),v("p",[v("strong",[a._v("Java 运行时数据区")]),a._v("不要和 "),v("strong",[a._v("Java 内存模型")]),a._v("（JMM）混淆。")]),a._v(" "),v("p",[a._v("Java 内存模型定义了 JVM 在计算机内存(RAM)中的工作方式，java 内存模型指的是一套规范，规范线程如何访问内存。")])]),a._v(" "),v("h2",{attrs:{id:"java-内存模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java-内存模型"}},[a._v("#")]),a._v(" Java 内存模型")]),a._v(" "),v("p",[v("img",{attrs:{src:t(346),alt:"20180413163825001"}})]),a._v(" "),v("p",[a._v("当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据同步到主存。")]),a._v(" "),v("p",[a._v("因为 cpu 是多核，同一个数据可能会有多个线程或者进程访问，因此有要一些措施要保证缓存的一致性。")]),a._v(" "),v("p",[v("strong",[a._v("Java 内存模型")]),a._v("就是规范 java  怎么去处理缓存一致性的。")]),a._v(" "),v("p",[a._v("比如 "),v("strong",[a._v("volatile")]),a._v(" 保证了可见性，Lock, synchronized 操作保证数据的可见性和原子性。")]),a._v(" "),v("h2",{attrs:{id:"java-运行时数据区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java-运行时数据区"}},[a._v("#")]),a._v(" Java 运行时数据区")]),a._v(" "),v("img",{staticStyle:{zoom:"67%"},attrs:{src:t(347),alt:"20180615135951001"}}),a._v(" "),v("p",[v("strong",[a._v("JVM 被分为三个主要的子系统")]),a._v("：")]),a._v(" "),v("ol",[v("li",[a._v("类加载器子系统")]),a._v(" "),v("li",[a._v("运行时数据区")]),a._v(" "),v("li",[a._v("执行引擎")])]),a._v(" "),v("p",[a._v("类加载子系统负责从文件系统或者网络中加载 Class 信息。")]),a._v(" "),v("p",[v("img",{attrs:{src:t(348),alt:"image-20210323171447455"}})]),a._v(" "),v("h3",{attrs:{id:"pc-寄存器-线程私有"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#pc-寄存器-线程私有"}},[a._v("#")]),a._v(" PC 寄存器（线程私有）")]),a._v(" "),v("p",[a._v("java 虚拟机中每个线程都有自己的 pc 寄存器。在任意时刻，一条线程只会执行一个方法代码。如果执行的方法不是 native，那么 pc 寄存器就保存正在执行的字节码指令的地址。如果是执行的是 native 方法，pc 寄存器的值是 null。PC 寄存区也是唯一一个不会抛出 OOM 异常的区域。")]),a._v(" "),v("h3",{attrs:{id:"java-虚拟机栈-线程私有"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java-虚拟机栈-线程私有"}},[a._v("#")]),a._v(" Java 虚拟机栈（线程私有）")]),a._v(" "),v("p",[a._v("每条线程都有自己的虚拟机栈，这个栈和线程同时创建，用于储存局部变量或者指向堆的指针。在 Java 虚拟机规范中，如果方法递归调用太深会抛出 StackOverflowError 异常；当无法申请足够的内存时也会抛出 OOM 异常。")]),a._v(" "),v("p",[a._v("-Xss 用于调节栈的大小。")]),a._v(" "),v("h3",{attrs:{id:"native-方法栈-线程私有"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#native-方法栈-线程私有"}},[a._v("#")]),a._v(" native 方法栈（线程私有）")]),a._v(" "),v("p",[a._v("调用 native 方法时使用的栈，了解即可。当栈溢出时，抛出 StackOverflowError 异常 ；当申请内存失败时，抛出 OOM 异常。")]),a._v(" "),v("h3",{attrs:{id:"堆-线程共享"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#堆-线程共享"}},[a._v("#")]),a._v(" 堆（线程共享）")]),a._v(" "),v("p",[a._v("堆（heap）是线程共享的区域，垃圾回收也主要回收它，我们主要也是堆打交道。-Xms 和 -Xmx 用于调整堆的大小。")]),a._v(" "),v("h3",{attrs:{id:"方法区-线程共享"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方法区-线程共享"}},[a._v("#")]),a._v(" 方法区（线程共享）")]),a._v(" "),v("p",[a._v("方法区是是一个规范，在 jdk 1.8 具体的实现是"),v("strong",[a._v("元空间")]),a._v(" 。")]),a._v(" "),v("p",[a._v("方法区是线程共享的内存区域，它存储 Class 的结构信息。例如，运行时常量池、字段、方法、构造函数。方法区使用的是本地内存（堆外内存），相当于在系统上申请的内存。方法区会抛出 OOM。")]),a._v(" "),v("p",[a._v("-XX:MaxMetaspaceSize: 设置，默认 -1 不限制。")]),a._v(" "),v("p",[a._v("-XX:MetaspaceSize:指定元空间初始空间大小。字节为单位。")])])}),[],!1,null,null,null);v.default=_.exports}}]);